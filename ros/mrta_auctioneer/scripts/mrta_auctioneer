#!/usr/bin/env python

"""mrta_auctioneer

This program serves as the task-allocating agent in a multirobot system. It is
responsible for:

  1. Loading a group of tasks that make up a "mission". These tasks may have
     dependencies among them (e.g., ordering), real-time constraints (e.g.,
     deadlines or windows), or other constraints. By "loading", we mean that
     tasks are read from a task- or mission-definition file at startup, received
     online from a mission-controlling agent (e.g., a person operating a GUI).

  2. Announcing tasks (in a particular order, if constrained) to team members.
     Tasks may be announced in groups, or "bundles".

  3. Receiving bids on tasks from team members. A bid is a real numbered value
     that (for now) represents the cost that a team member estimates it will
     incur to complete the task. For example, the distance it will need to
     travel to reach a certain point in the world.

  4. Determining the "winner" of every task. A winner is usually the team
     member that submitted the lowest bid.

The term "mechanism" refers to the way in which tasks are announced, bids collected,
and tasks are awarded. Depending on the mechanism, the announcement and bid collection
phases may be skipped (e.g., in a round-robin mechanism).

Usage: auctioneer.py ['RR'|'PSI'|'OSI'|'SSI'] [path to task definition file]

  The first argument specifies the mechanism to use. These abbreviations stand for
  "round robin", "parallel single-item", "ordered single-item", and "sequential
  single-item", respectively. These mechanisms are explained in [1].

  The second argument gives the path to a file whose contents specify the
  set of tasks that make up a mission. The format of this file is explained
  in [TODO].


Eric Schneider <eric.schneider@liverpool.ac.uk>

[1] Schneider, Balas, et al. 2014. An empirical evaluation of auction-based task allocation in multi-robot teams. In Proceedings of the 2014 international conference on Autonomous agents and multi-agent systems (AAMAS '14).
"""

# Standard Python modules
from collections import defaultdict
import itertools
import os
import pprint
import re
from sets import Set
import signal
import sys
from threading import Timer
import time
import uuid
import yaml

# Fysom state machine
from fysom import Fysom

# ROS modules
# import actionlib
from collections import defaultdict
# import geometry_msgs.msg
# import move_base_msgs.msg
# import nav_msgs.msg
# import rosgraph
# import rosgraph.names
import rosnode
import rospy
import rospy.rostime

import mrta
import mrta.msg

# TODO:
# Import Task class

# We'll sleep 1/RATE seconds in every pass of the idle loop.
RATE = 10

pp = pprint.PrettyPrinter(indent=2)


def on_sigint(signal):
    print('Caught SIGINT, shutting down...')
    sys.exit(0)


def stamp(msg):
    """ Set the timestamp of a message to the current wall-clock time."""
    rospy.rostime.switch_to_wallclock()
    msg.header.stamp = rospy.rostime.get_rostime()


class Auction(object):
    def __init__(self, auctioneer=None, tasks=None, auction_round=None):
        
        # A handle to the Auctioneer object who called us
        self.auctioneer = auctioneer

        # The tasks we are meant to announce/award in the current round
        self.tasks = tasks

        # To identify in which round bids are made for tasks
        self.auction_round = auction_round

        # Set up state machine.
        # See multirobot/docs/auctioneer-fsm.png
        self.fsm = Fysom( 
            events=[
                ('startup', 'none', 'announce'),
                ('announced', 'announce', 'collect_bids'),
                ('bids_collected', 'collect_bids', 'determine_winner'),
                ('winner_determined', 'determine_winner', 'award'),
            ],
            callbacks={
                # on-enter state handlers
                'onannounce': self.announce,
                'oncollect_bids': self.collect_bids,
                'ondetermine_winner': self.determine_winner,
                'onaward': self.award
                
                # on-event handlers
                # 'onchoose_OSI': self.choose_OSI
            }
        )

        # Start the state machine
        self.fsm.startup()

    def _construct_task_msg(self, task):
        """
        Maps from our internal task representation to a ROS message type.
        (mrta.SensorSweepTask => mrta.msg.SensorSweepTask)
        """
        # Just sensor sweep tasks for now
        task_msg = mrta.msg.SensorSweepTask()

        task_msg.task.task_id = task.task_id
        task_msg.task.depends = task.depends
        task_msg.task.type = task.type
        task_msg.task.num_robots = task.num_robots
        task_msg.task.duration = task.duration
        task_msg.location.x = task.location.x
        task_msg.location.y = task.location.y
        task_msg.location.z = task.location.z

        return task_msg

    def _construct_announcement_msg(self):
        pass

    def _get_task_by_id(self, task_id):
        return self.auctioneer.tasks_by_id[task_id]

    def announce(self, e):
        pass

    def collect_bids(self, e):
        """
        Here, we can either wait for a time limit (deadline) to pass or,
        knowing the size of the team and the mechanism being used, we can
        calculate how many bids we expect to receive before we consider
        the bid collection phase finished.

        Before the time limit passes, we expect to receive bid messages, which
        will trigger Auctioneer.on_bid_received().
        """
        pass
            
    def determine_winner(self, e):
        pass

    def award(self, e):
        pass


class AuctionOSI(Auction):

    mechanism_name = 'OSI'

    def __init__(self, auctioneer=None, tasks=None, auction_round=None):
        super(AuctionOSI, self).__init__(auctioneer, tasks, auction_round)

    def _construct_announcement_msg(self):
        announce_msg = mrta.msg.AnnounceSensorSweep()
        announce_msg.mechanism = self.mechanism_name

        # Only announce one task (the first in the auctioneer's list)
        announce_msg.tasks.append(self._construct_task_msg(self.tasks[0]))

        return announce_msg

    def announce(self, e):
        rospy.loginfo("(OSI) state: announce")

        while not self.auctioneer.team_members:
            rospy.logdebug("..waiting for team to be non-empty")
            time.sleep(1)
        
        announcement_msg = self._construct_announcement_msg()
        stamp(announcement_msg)
        self.auctioneer.announce_pub.publish(announcement_msg)

        rospy.loginfo("Announcement:\n{0}".format(pp.pformat(announcement_msg)))

        self.fsm.announced()

    def collect_bids(self, e):
        rospy.loginfo("(OSI) state: collect_bids")

        bids = self.auctioneer.bids[self.auction_round]

        # In OSI, we wait to receive as many bids as there are team members
        while len(bids) < len(self.auctioneer.team_members):
            # time.sleep(0.2)
            self.auctioneer.rate.sleep()

        self.fsm.bids_collected(task_id=self.tasks[0].task_id)

    def determine_winner(self, e):
        rospy.loginfo("(OSI) state: determine_winner")

        # The id and task that we are assigning in this round
        task_id = e.task_id
        task = self._get_task_by_id(task_id)

        bids = self.auctioneer.bids[self.auction_round]
        bid_tuples = []
        for robot_id in bids.keys():
            if robot_id not in self.auctioneer.awarded[task_id]:
                bid_tuples.append([robot_id, bids[robot_id][task_id]]) # i.e., [robot_id, bid_value]

        # Sort tuples of [robot_id],[bid_value] in ascending order of bid value
        bid_tuples = sorted(bid_tuples, key=lambda entry: entry[1])

        # For now, award the single lowest bidder. But we may want to award the 'num_robots' lowest bidders
        # per round (i.e., bid_tuples[:num_robots] rather than bid_tuples[0], below)
        num_robots = task.num_robots
        winner_ids = map(lambda entry: entry[0], bid_tuples[:num_robots])
#        winner_ids = map(lambda entry: entry[0], bid_tuples[:1])

        self.auctioneer.awarded[task_id].extend(winner_ids)

        rospy.loginfo("winner(s) of task {0}: '{1}'".format(task_id, winner_ids))

        self.fsm.winner_determined(task_id=task_id, winner_ids=winner_ids)

    def award(self, e):
        """ Construct and send an award message. """
        rospy.loginfo("(OSI) state: award")

        won_task = self._get_task_by_id(e.task_id)

        winner_ids = e.winner_ids

        for winner_id in winner_ids:
            award_msg = mrta.msg.TaskAward()
            award_msg.robot_id = winner_id
            task_msg = self._construct_task_msg(won_task)
            award_msg.tasks.append(task_msg)

            stamp(award_msg)
            self.auctioneer.award_pub.publish(award_msg)

            won_task.num_robots_allocated += 1

        # Mark the task as awarded if the task has been awarded to its required
        # number of robots
        if won_task.num_robots_allocated == won_task.num_robots:
            won_task.awarded = True


class AuctionPSI(Auction):

    mechanism_name = 'PSI'

    def __init__(self, auctioneer=None, tasks=None, auction_round=None):
        super(AuctionPSI, self).__init__(auctioneer, tasks, auction_round)

    def _construct_announcement_msg(self):
        announce_msg = mrta.msg.AnnounceSensorSweep()
        announce_msg.mechanism = self.mechanism_name

        # Announce all messages at once
        for task in self.tasks:
            announce_msg.tasks.append(self._construct_task_msg(task))

        return announce_msg

    def announce(self, e):
        rospy.loginfo("(PSI) state: announce")

        while not self.auctioneer.team_members:
            rospy.logdebug("..waiting for team to be non-empty")
            time.sleep(1)

        announcement_msg = self._construct_announcement_msg()
        stamp(announcement_msg)
        self.auctioneer.announce_pub.publish(announcement_msg)

        rospy.logdebug("Announcement:\n{0}".format(pp.pformat(announcement_msg)))

        self.fsm.announced()

    def collect_bids(self, e):
        rospy.loginfo("(PSI) state: collect_bids")

        bids = self.auctioneer.bids[self.auction_round]

        # In PSI, the number of bids we expect to receive is [#tasks]*[team size]
        bid_count = 0
        while bid_count < len(self.tasks) * len(self.auctioneer.team_members):
            bid_count = 0
            for robot_id in bids:
                for task_id in bids[robot_id]:
                    bid_count += 1

            # time.sleep(0.2)
            self.auctioneer.rate.sleep()

        self.fsm.bids_collected()

    def determine_winner(self, e):
        rospy.loginfo("(PSI) state: determine_winner")
        
        bids = self.auctioneer.bids[self.auction_round]

        rospy.logdebug("bids:\n{0}".format(pp.pformat(bids)))

        # We'll determine the winner of and send an award message for each task
        task_winners = defaultdict(list) # task_winners[task_id] = [winner_ids]

        for task in self.tasks:

            bid_tuples = []
            for robot_id in bids.keys():
                if robot_id not in self.auctioneer.awarded[task.task_id]:
                    bid_tuples.append([robot_id, bids[robot_id][task.task_id]]) # i.e., [robot_id, bid_value]

            # Sort tuples of [robot_id],[bid_value] in ascending order of bid value
            bid_tuples = sorted(bid_tuples, key=lambda entry: entry[1])

            num_robots = task.num_robots
            # The top (actually lowest) num_robots bids
            winner_ids = map(lambda entry: entry[0], bid_tuples[:num_robots])

            self.auctioneer.awarded[task.task_id].extend(winner_ids)

            rospy.loginfo("winner(s) of task {0}: '{1}'".format(task.task_id, winner_ids))

            task_winners[task.task_id] = winner_ids

        self.fsm.winner_determined(task_winners=task_winners)

    def award(self, e):
        """ Construct and send an award message for each winner. """
        rospy.loginfo("(PSI) state: award")

        task_winners = e.task_winners

        for task_id in task_winners:
            won_task = self._get_task_by_id(task_id)

            for winner_id in task_winners[task_id]:

                award_msg = mrta.msg.TaskAward()
                award_msg.robot_id = winner_id

                task_msg = self._construct_task_msg(won_task)
                award_msg.tasks.append(task_msg)

                self.auctioneer.award_pub.publish(award_msg)

                rospy.logdebug("sending award message:\n{0}".format(pp.pformat(award_msg)))

            # Mark the task as awarded
            won_task.awarded = True


class AuctionSSI(Auction):
    """ A Sequential Single-Item auction.

    See:
    Koenig, Sven, et al. "The power of sequential single-item auctions for agent
    coordination." Proceedings of the National Conference on Artificial
    Intelligence. Vol. 21. No. 2. Menlo Park, CA; Cambridge, MA; London; AAAI
    Press; MIT Press; 1999, 2006.
    """
    mechanism_name = 'SSI'

    def __init__(self, auctioneer=None, tasks=None, auction_round=None):
        super(AuctionSSI, self).__init__(auctioneer, tasks, auction_round)

    def _construct_announcement_msg(self):
        announce_msg = mrta.msg.AnnounceSensorSweep()
        announce_msg.mechanism = self.mechanism_name

        # Announce all messages at once
        for task in self.tasks:
            announce_msg.tasks.append(self._construct_task_msg(task))

        return announce_msg

    def announce(self, e):
        rospy.loginfo("(SSI) state: announce")

        while not self.auctioneer.team_members:
            rospy.logdebug("..waiting for team to be non-empty")
            time.sleep(1)

        announcement_msg = self._construct_announcement_msg()
        stamp(announcement_msg)
        self.auctioneer.announce_pub.publish(announcement_msg)

        rospy.logdebug("Announcement:\n{0}".format(pp.pformat(announcement_msg)))

        self.fsm.announced()

    def collect_bids(self, e):
        rospy.loginfo("(SSI) state: collect_bids")

        bids = self.auctioneer.bids[self.auction_round]

        # In SSI, we wait to receive as many bids as there are team members
        while len(bids) < len(self.auctioneer.team_members):
            time.sleep(0.1)

        self.fsm.bids_collected()

    def determine_winner(self, e):
        rospy.loginfo("(SSI) state: determine_winner")

        bids = self.auctioneer.bids[self.auction_round]
        bid_tuples = []
        for robot_id in bids:
            for task_id in bids[robot_id]:
                if robot_id not in self.auctioneer.awarded[task_id]:
                    bid_tuples.append([robot_id, task_id, bids[robot_id][task_id]]) # i.e., [robot_id, task_id, bid_value]

        # Sort tuples of [robot_id],[bid_value] in ascending order of bid value
        bid_tuples = sorted(bid_tuples, key=lambda entry: entry[2])

        rospy.loginfo("bid_tuples: {0}".format(pp.pformat(bid_tuples)))

        # For now, award the single lowest bidder. But we may want to award the 'num_robots' lowest bidders
        # per round (i.e., bid_tuples[:num_robots] rather than bid_tuples[0] for the minimum-bid task, below)
        # num_robots = self._get_task_by_id(bid_tuples[0][1]).num_robots
        # winner_ids = map(lambda entry: entry[0], bid_tuples[:num_robots])
        winner_ids = map(lambda entry: entry[0], bid_tuples[:1])
        winning_task_id = bid_tuples[0][1]

        self.auctioneer.awarded[winning_task_id].extend(winner_ids)

        rospy.loginfo("winner(s) of task {0}: '{1}'".format(winning_task_id, winner_ids))

        self.fsm.winner_determined(task_id=winning_task_id, winner_ids=winner_ids)

    def award(self, e):
        """ Construct and send an award message. """
        rospy.loginfo("(SSI) state: award")

        won_task = self._get_task_by_id(e.task_id)

        winner_ids = e.winner_ids

        for winner_id in winner_ids:
            award_msg = mrta.msg.TaskAward()
            award_msg.robot_id = winner_id
            task_msg = self._construct_task_msg(won_task)
            award_msg.tasks.append(task_msg)

            stamp(award_msg)
            self.auctioneer.award_pub.publish(award_msg)

            won_task.num_robots_allocated += 1

        # Mark the task as awarded if the task has been awarded to its required
        # number of robots
        if won_task.num_robots_allocated == won_task.num_robots:
            won_task.awarded = True


class AuctionRR(Auction):

    mechanism_name = 'RR'

    def __init__(self, auctioneer=None, tasks=None, auction_round=None):
        super(AuctionRR, self).__init__(auctioneer, tasks, auction_round)

    def _construct_announcement_msg(self):
        announce_msg = mrta.msg.AnnounceSensorSweep()
        announce_msg.mechanism = self.mechanism_name

        # Only announce one task (the first in the auctioneer's list)
        announce_msg.tasks.append(self._construct_task_msg(self.tasks[0]))

        return announce_msg

    def announce(self, e):
        rospy.loginfo("(RR) state: announce")
        rospy.loginfo("..skipping!")

        self.fsm.announced()

    def collect_bids(self, e):
        rospy.loginfo("(RR) state: collect_bids")
        rospy.loginfo("..skipping!")

        self.fsm.bids_collected()

    def determine_winner(self, e):
        rospy.loginfo("(RR) state: determine_winner")
        rospy.loginfo("..skipping!")

        self.fsm.winner_determined()

    def award(self, e):
        """ Construct and send an award message for each task. """
        rospy.loginfo("(RR) state: award")

        # A cycling iterator of team member names
        # team_cycle = itertools.cycle(self.auctioneer.team_members)

        for task in self.tasks:

            while not task.awarded:

                award_msg = mrta.msg.TaskAward()

                # award_msg.robot_id = team_cycle.next()
                award_msg.robot_id = self.auctioneer._team_cycle.next()

                task_msg = self._construct_task_msg(task)
                award_msg.tasks.append(task_msg)

                rospy.logdebug("sending award message:\n{0}".format(pp.pformat(award_msg)))

                stamp(award_msg)
                self.auctioneer.award_pub.publish(award_msg)

                task.num_robots_allocated += 1

                # Mark the task as awarded if the task has been awarded to its required
                # number of robots
                if task.num_robots_allocated == task.num_robots:
                    task.awarded = True


class Auctioneer:

    def __init__(self, mechanism=None, task_file=None):
        """
        Initialize some ROS stuff (topics to publish/subscribe) and our state machine.
        """

        # Initialize our node
        # Do we need a special name for the auctioneer (i.e., not "auctioneer")?
        node_name = 'auctioneer'
        rospy.loginfo("Starting node '{0}'...".format(node_name))
        rospy.init_node(node_name)

        # Topics we wish to subscribe to
        self.bid_sub = self.status_sub = self.new_sub = None
        self.init_subscribers()

        # Topics we wish to publish
        self.experiment_pub = self.announce_pub = self.award_pub = None
        self.init_publishers()

        # The rate at which we'll sleep while idle
        self.rate = rospy.Rate(RATE)

        # A list of (node) names of robot team members.
        self.team_members = []

        # A cycling iterator
        self._team_cycle = None

        # A list of (node) names team members who have completed
        # all of their tasks.
        self.team_members_completed = []

        # We will use one mechanism per run (for now)
        # self.mechanism = mechanism
        self.mechanism = rospy.get_param('~mechanism')

        # Tasks are loaded from a configuration file, rather than
        # loaded dynamically (for now)
        # self.task_file = task_file
        self.task_file = None
        try:
            self.task_file = rospy.get_param('~task_file')
        except KeyError:
            rospy.logerr("Parameter 'task_file' has no value!")

        # Scripted tasks that are not necessarily 'live' at the start of the experiment
        self.scripted_tasks = []
        self.scripted_tasks_by_id = {}

        # A simple list for now
        self.tasks = []

        # We also want to be able to get tasks by id
        self.tasks_by_id = {}

        # Timers for tasks to 'appear'
        self.task_timers = []

        # If a new task has been 'generated'. Hacky, refactor.
        self.new_task_added = False

        # To identify in which round bids are made for tasks
        self.auction_round = 0

        # Keep track of bids, indexed by auction_round, task_id and robot_id
        self.bids = defaultdict(int)

        # Keep track of which robots have been awarded which tasks
        # task_id => list of robot_name
        self.awarded = defaultdict(list)

        # Set up state machine.
        # See mrta/docs/auctioneer-fsm.png
        self.fsm = Fysom( 
            events=[
                ('startup', 'none', 'load_tasks'),
                ('tasks_loaded', 'load_tasks', 'identify_team'),
                ('do_identify_team', '*', 'identify_team'),
                ('team_identified', 'identify_team', 'idle'),
                ('have_tasks', 'idle', 'choose_mechanism'),
                ('allocation_complete', 'choose_mechanism', 'monitor_execution'),
                ('current_tasks_complete', 'monitor_execution', 'end_execution'),
                ('have_tasks', 'end_execution', 'idle'),
                ('all_scripted_tasks_complete', '*', 'end_experiment'),
            ],
            callbacks={
                # on-enter state handlers
                'onload_tasks': self.load_tasks,
                'onidentify_team': self.identify_team,
                'onidle': self.idle,
                'onchoose_mechanism': self.choose_mechanism,
                'onmonitor_execution': self.monitor_execution,
                'onend_execution': self.end_execution,
                'onend_experiment': self.end_experiment,
                # on-event handlers
            }
        )

        # Generate a unique, random experiment id
        self.experiment_id = str(uuid.uuid4())

        # Send a message to mark the beginning of the experiment
        begin_exp_msg = mrta.msg.ExperimentEvent()
        begin_exp_msg.experiment_id = self.experiment_id
        begin_exp_msg.event = mrta.msg.ExperimentEvent.BEGIN_EXPERIMENT
        stamp(begin_exp_msg)
        self.experiment_pub.publish(begin_exp_msg)

        # Start the state machine
        self.fsm.startup()

    def init_subscribers(self):
        rospy.loginfo('Initializing subscribers...')

        # Listen for bids on '/tasks/bid'
        self.bid_sub = rospy.Subscriber('/tasks/bid',
                                        mrta.msg.TaskBid,
                                        self.on_bid_received)

        self.status_sub = rospy.Subscriber('/tasks/status',
                                           mrta.msg.TaskStatus,
                                           self.on_task_status)

        self.new_sub = rospy.Subscriber('/tasks/new',
                                        mrta.msg.SensorSweepTask,
                                        self.on_new_task)

        # For good measure...
        time.sleep(3)

    def init_publishers(self):

        # Announce experiment events on '/experiment'.
        # Importantly, 'BEGIN_ALLOCATION', 'END_ALLOCATION', and
        # 'BEGIN_EXECUTION'.
        self.experiment_pub = rospy.Publisher('/experiment',
                                              mrta.msg.ExperimentEvent,
                                              queue_size=3)

        # Announce tasks on '/tasks/announce'. For the moment we will only
        # announce sensor sweep tasks.
        self.announce_pub = rospy.Publisher('/tasks/announce',
                                            mrta.msg.AnnounceSensorSweep,
                                            queue_size=3)

        # Award tasks on '/tasks/award'
        self.award_pub = rospy.Publisher('/tasks/award',
                                         mrta.msg.TaskAward,
                                         queue_size=3)

        # For good measure...
        time.sleep(5)

    def on_new_task(self, new_task_msg):
        rospy.loginfo("Received new task: {0}".format(pp.pformat(new_task_msg)))
        
        new_task = mrta.SensorSweepTask(str(new_task_msg.task.task_id),
                                        float(new_task_msg.location.x),
                                        float(new_task_msg.location.y))
        self.tasks.append(new_task)

    def add_scripted_task(self, task_id):
        rospy.loginfo("'Adding' scripted task {0}...".format(task_id))

        scripted_task = self.scripted_tasks_by_id[task_id]
        self.tasks.append(scripted_task)
        self.tasks_by_id[scripted_task.task_id] = scripted_task

        self.new_task_added = True
        rospy.loginfo("self.new_task_added=={0}".format(self.new_task_added))

        rospy.loginfo("add_scripted_task(): current state=={0}".format(self.fsm.current))

    def load_tasks(self, data):
        rospy.loginfo("Loading tasks from {0}...".format(self.task_file))

        if not self.task_file:
            rospy.logerror("No task file given!")
            return

        try:
            task_file = open(self.task_file, 'rb')

            yaml_tasks = yaml.load(task_file)

            for yaml_task in yaml_tasks:

                # task_id is string-ified here because an id may one day be
                # an MD5 hash or some other non-integer value. They just happen
                # to be integers here.
                new_task = mrta.SensorSweepTask(str(yaml_task['task_id']),
                                                float(yaml_task['location']['x']),
                                                float(yaml_task['location']['y']),
                                                0.0, # z
                                                int(yaml_task['num_robots']),
                                                float(yaml_task['duration']),
                                                yaml_task['depends'])

                rospy.loginfo("auctioneer: task '{0}' depends on {1}".format(new_task.task_id, new_task.depends))

                self.scripted_tasks.append(new_task)
                self.scripted_tasks_by_id[str(yaml_task['task_id'])] = new_task
                
                self.task_timers.append(Timer(float(yaml_task['arrival_time']),
                                              self.add_scripted_task,
                                              [str(yaml_task['task_id'])]))

        except Exception as e:
            rospy.logerr("Can't open/parse task file {0}!".format(self.task_file))
            e_type, e_value, e_traceback = sys.exc_info()
            rospy.logerr("{0}: {1}".format(e_type, e_value))
            # rospy.logerr("{0}".format(e_traceback.format_exc()))

        rospy.loginfo("Scripted Tasks:\n{0}".format(pp.pformat(self.scripted_tasks_by_id)))

        # Start timers
        for task_timer in self.task_timers:
            task_timer.start()
            # Sleep a tiny bit to make sure they're loaded
            time.sleep(0.1)

        self.fsm.tasks_loaded()

    def identify_team(self, data):
        rospy.loginfo("Identifying team...")

        # In the 'rosnode' utility/module, _sub_rosnode_listnodes() returns a
        # newline-separated list of the names of all nodes in the graph.
        # See http://wiki.ros.org/rosnode
        node_list = rosnode._sub_rosnode_listnodes().split()

        # We're finding namespaces that look like the following pattern
        # (in parens):
        name_pat = re.compile('/(.*)/mrta_robot_controller')
        for node_name in node_list:
            m = name_pat.match(node_name)
            if m:
                teammate_name = m.group(1)
                rospy.loginfo("Adding {0} to team".format(teammate_name))
                self.team_members.append(teammate_name)

        # TEMP HACK!
        self.team_members = ['robot_1', 'robot_2', 'robot_3']

        self._team_cycle = itertools.cycle(self.team_members)
        
        rospy.loginfo("Team members: {0}".format(self.team_members))

        self.fsm.team_identified()

    def idle(self, data):
        rospy.loginfo("state: idle")

        # There are scripted (dynamic) tasks yet to come
        incomplete_scripted_tasks = True
        while incomplete_scripted_tasks:

            self.rate.sleep()

            incomplete_scripted_tasks = False
            for scripted_task in self.scripted_tasks:
                if not scripted_task.completed:
                    incomplete_scripted_tasks = True
                    break

            unallocated = False
            for task in self.tasks:
                if not task.awarded:
                    unallocated = True
                    break

            if unallocated:
                break

        if unallocated:
            # Transition to the "choose_mechanism" state
            rospy.loginfo("Have unallocated tasks. Allocating...")
            self.fsm.have_tasks()
        else:
            self.fsm.all_scripted_tasks_complete()

    def choose_mechanism(self, e):
        rospy.loginfo("state: choose_mechanism")

        time.sleep(0.2)

        # Send a message to mark the beginning of the allocation phase of
        # the experiment
        begin_alloc_msg = mrta.msg.ExperimentEvent()
        begin_alloc_msg.experiment_id = self.experiment_id
        begin_alloc_msg.event = mrta.msg.ExperimentEvent.BEGIN_ALLOCATION
        stamp(begin_alloc_msg)
        self.experiment_pub.publish(begin_alloc_msg)

        # For now, use the single mechanism given to us as a parameter
        rospy.loginfo("  {0}".format(self.mechanism))

        # As long as there are unallocated tasks, choose a mechanism and
        # allocate them.
        while True:
            unallocated = []
            for task in self.tasks:
                if not task.awarded:
                    unallocated.append(task)

            if not unallocated:
                break

            self.auction_round += 1
            self.bids[self.auction_round] = defaultdict(str)

            if self.mechanism == 'OSI':
                auction_osi = AuctionOSI(self, unallocated, self.auction_round)
            elif self.mechanism == 'PSI':
                auction_psi = AuctionPSI(self, unallocated, self.auction_round)
            elif self.mechanism == 'SSI':
                auction_ssi = AuctionSSI(self, unallocated, self.auction_round)
            elif self.mechanism == 'RR':
                auction_rr = AuctionRR(self, unallocated, self.auction_round)

        # At this point, we can (safely?) consider all tasks awarded

        self.new_task_added = False
        rospy.loginfo("self.new_task_added == {0}".format(self.new_task_added))

        # We are finished allocating tasks. Signal the end of the allocation
        # phase and the beginning of the execution phase.
        end_alloc_msg = mrta.msg.ExperimentEvent()
        end_alloc_msg.experiment_id = self.experiment_id
        end_alloc_msg.event = mrta.msg.ExperimentEvent.END_ALLOCATION
        stamp(end_alloc_msg)
        self.experiment_pub.publish(end_alloc_msg)

        begin_exec_msg = mrta.msg.ExperimentEvent()
        begin_exec_msg.experiment_id = self.experiment_id
        begin_exec_msg.event = mrta.msg.ExperimentEvent.BEGIN_EXECUTION
        stamp(begin_exec_msg)
        self.experiment_pub.publish(begin_exec_msg)

        self.fsm.allocation_complete()

    def on_bid_received(self, bid_msg):
        task_id = bid_msg.task_id
        robot_id = bid_msg.robot_id
        bid = bid_msg.bid

        round_bids = self.bids[self.auction_round]
        
        if not round_bids[robot_id]:
            round_bids[robot_id] = {}

        round_bids[robot_id][task_id] = float(bid)

        rospy.loginfo("{0} bid {1} for task {2} in auction round {3}".format(
            robot_id, bid, task_id, self.auction_round))

    def on_task_status(self, status_msg):
        robot_id = status_msg.robot_id
        task_id = status_msg.task_id
        status = status_msg.status

        # We mainly want to keep track of robots that have
        # completed all of their tasks
        if status == mrta.msg.TaskStatus.ALL_TASKS_COMPLETE:
            rospy.loginfo("Received ALL_TASKS_COMPLETE from {0}".format(robot_id))
            self.team_members_completed.append(robot_id)

        if status == mrta.msg.TaskStatus.SUCCESS:
            rospy.loginfo("{0} has completed task {1}".format(robot_id, task_id))
            self.tasks_by_id[task_id].completed = True

    def monitor_execution(self, e):
        rospy.loginfo('state: monitor_execution')

        # Wait until all of the tasks (that have been allocated so far) are complete
        incomplete = True
        while incomplete and not self.new_task_added:

            incomplete = False
            for task in self.tasks:
                if not task.completed:
                    incomplete = True
                    break

            # time.sleep(0.2)
            self.rate.sleep()

        rospy.loginfo("Stopping task execution.")
        rospy.loginfo("incomplete=={0}".format(incomplete))
        rospy.loginfo("self.new_task_added=={0}".format(self.new_task_added))

        # Either:
        # 1. All tasks (that have been allocated so far) have been completed.
        # OR
        # 2. Some new, scripted task has been added
        # End the current execution phase of the experiment.
        self.fsm.current_tasks_complete()

    def end_execution(self, e):
        rospy.loginfo("state: end_execution")

        # Send a message to mark the end of the execution phase
        end_exec_msg = mrta.msg.ExperimentEvent()
        end_exec_msg.experiment_id = self.experiment_id
        end_exec_msg.event = mrta.msg.ExperimentEvent.END_EXECUTION
        stamp(end_exec_msg)
        self.experiment_pub.publish(end_exec_msg)

        incomplete_scripted_tasks = False
        for scripted_task in self.scripted_tasks:
            if not scripted_task.completed:
                incomplete_scripted_tasks = True
                break
        
        if incomplete_scripted_tasks:
            rospy.loginfo("end_execution: there are incomplete scripted tasks")
            self.fsm.have_tasks()
        else:
            rospy.loginfo("end_execution: all scripted tasks are complete")
            self.fsm.all_scripted_tasks_complete()

    def end_experiment(self, e):
        rospy.loginfo("state: end_experiment")

        # Send a message to mark the end of the experiment
        end_exp_msg = mrta.msg.ExperimentEvent()
        end_exp_msg.experiment_id = self.experiment_id
        end_exp_msg.event = mrta.msg.ExperimentEvent.END_EXPERIMENT
        stamp(end_exp_msg)
        self.experiment_pub.publish(end_exp_msg)

        rospy.loginfo("Shutting down...")

        # Instead of exiting, wait to be shut down from outside
        while not rospy.is_shutdown():
            self.rate.sleep()

if __name__ == '__main__':
    # Exit on ctrl-C
    signal.signal(signal.SIGINT, on_sigint)

    try:
        argv = rospy.myargv(argv=sys.argv[1:])
        auc = Auctioneer(*argv)
    except rospy.ROSInterruptException:
        pass
