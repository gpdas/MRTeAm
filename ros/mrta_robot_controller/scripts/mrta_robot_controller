#!/usr/bin/env python

"""mrta_robot_controller

This script (and class) controls the task-bidding and goal-seeking behavior of a
robot.

Usage: robot_controller.py [robot_name] [goal-x-pos] [goal-y-pos]

 robot_name: the desired ROS node name of the robot. If none is given, then a
  random name is chosen.

The RobotController class uses a state machine to implement bidding and goal-
seeking behavior.

Eric Schneider <eric.schneider@liverpool.ac.uk>
"""

# Standard Python modules
from collections import defaultdict
import math
import pprint
import random
import sys
import time
import uuid

# Fysom state machine
from fysom import Fysom

# ROS modules
import actionlib
from actionlib import SimpleActionClient
import actionlib_msgs.msg
import geometry_msgs.msg
import move_base_msgs.msg
import nav_msgs.msg
import nav_msgs.srv
import navfn.srv
import rospy
import smach
import smach_ros
from smach_ros import SimpleActionState
import std_srvs.srv
import tf.transformations
#from std_msgs.msg import String

import mrta
import mrta.msg

# We'll sleep 1/RATE seconds in every pass of the idle loop.
RATE = 10

# If another robot is with this distance (in meters) and field of view (in
# radians), we're in danger of colliding with it
#DANGER_ZONE_FOV = math.pi / 2
DANGER_ZONE_FOV = math.pi
DANGER_ZONE_DIST = 0.9

pp = pprint.PrettyPrinter(indent=2)


######## smach state classes ########

# state: IDLE
class Idle(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['have_tasks', 'all_tasks_complete'],
                             input_keys=['robot_controller'],
                             output_keys=['robot_controller'])

    def execute(self, userdata):
        rc = userdata.robot_controller

        rospy.loginfo("[{0}] state: idle".format(rc.robot_name))

        # We idle here unless two conditions are true:
        # 1. We have tasks in our agenda
        # 2. self.ok_to_execute == True
        while not rc.agenda or not rc.ok_to_execute:
            rc.rate.sleep()

        have_tasks = False
        for task in rc.agenda:
            if not task.completed:
                have_tasks = True
                break

        if have_tasks:
            return 'have_tasks'
        else:
            return 'no_tasks'

# state: CHOOSE_TASK
class ChooseTask(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['goal_chosen','no_tasks'],
                             input_keys=['robot_controller'],
                             output_keys=['robot_controller'])

    def execute(self, userdata):
        rc = userdata.robot_controller

        rospy.loginfo("[{0}] state: idle".format(rc.robot_name))

        # We have two ways to choose the next task from our agenda:
        # 1. ("non-greedy") Choose the first task that hasn't been completed yet
        # 2. ("greedy")     Choose the next closest task

        greedy_selection = True

        # "non-greedy"
        goal_task = None
        min_uncompleted_dist = None
        for task in rc.agenda:
            if not task.completed:
                if greedy_selection:
                    from_pose = rc.current_pose
                    to_pose = rc._point_to_pose(rc._point_to_point_msg(task.location))
                    path_cost = rc.get_path_cost(from_pose, to_pose)

                    if not min_uncompleted_dist or path_cost < min_uncompleted_dist:
                        goal_task = task
                        min_uncompleted_dist = path_cost

                else:
                    goal_task = task
                    break

        rc.current_task = goal_task

        # Sanity check
        if not rc.current_task:
            rospy.loginfo("outcome: no_tasks")
            return 'no_tasks'

        rospy.loginfo("outcome: goal_chosen")
        return 'goal_chosen'

# state: SEND_GOAL
class SendGoal(smach.State):
    def __init__(self):
        smach.State.__init__(self,
                             outcomes=['have_tasks', 'all_tasks_complete'],
                             input_keys=['robot_controller'],
                             output_keys=['robot_controller'])

    def execute(self, userdata):
        rc = userdata.robot_controller

        rospy.loginfo("[{0}] state: idle".format(rc.robot_name))

        # We idle here unless two conditions are true:
        # 1. We have tasks in our agenda
        # 2. self.ok_to_execute == True
        while not rc.agenda or not rc.ok_to_execute:
            rc.rate.sleep()

        have_tasks = False
        for task in rc.agenda:
            if not task.completed:
                have_tasks = True
                break

        if have_tasks:
            return 'have_tasks'
        else:
            return 'no_tasks'


#### Utility functions

def stamp(msg):
    """ Set the timestamp of a message to the current wall-clock time."""
    rospy.rostime.switch_to_wallclock()
    msg.header.stamp = rospy.rostime.get_rostime()

def in_danger_zone(my_pose, other_pose):

    in_danger = False

    if not my_pose or not other_pose:
        return in_danger

    # Angle between my_pose and the positive y-axis

    # my_pose orientation quaternion
    my_q = (my_pose.orientation.x,
            my_pose.orientation.y,
            my_pose.orientation.z,
            my_pose.orientation.w)
    euler = tf.transformations.euler_from_quaternion(my_q)
    my_yaw = euler[2]
    rospy.logdebug("my_yaw == {0}".format(my_yaw))
    d_theta = (math.pi / 2) - my_yaw
    rospy.logdebug("d_theta == {0}".format(d_theta))

    # Translate the treasure's position, pretending the robot is at the origin
    trans_x = other_pose.position.x - my_pose.position.x
    trans_y = other_pose.position.y - my_pose.position.y
    rospy.logdebug("trans_x=={0}, trans_y=={1}".format(trans_x, trans_y))


    # Rotate the translated point by d_theta
    rot_x = (trans_x * math.cos(d_theta)) - (trans_y * math.sin(d_theta))
    rot_y = (trans_x * math.sin(d_theta)) + (trans_y * math.cos(d_theta))
    rospy.logdebug("rot_x=={0}, rot_y=={1}".format(rot_x, rot_y))

    other_heading = math.atan2(rot_x, rot_y)
    rospy.logdebug("other_pos heading is {0}".format(other_heading))

    other_dist = math.hypot(other_pose.position.x - my_pose.position.x,
                            other_pose.position.y - my_pose.position.y)

    in_fov = False
    if (other_heading >= -(DANGER_ZONE_FOV/2) and
        other_heading <= (DANGER_ZONE_FOV/2)):
        in_fov = True

    rospy.logdebug("in_fov=={0}".format(in_fov))

    in_dist = False
    if other_dist <= DANGER_ZONE_DIST:
        in_dist = True
    rospy.logdebug("in_dist=={0}".format(in_dist))

    if in_fov and in_dist:
        in_danger = True
    rospy.logdebug("in_danger=={0}".format(in_danger))

    return in_danger


class Collision(object):
    def __init__(self):
        pass

class RobotController:
    """ Controls robot behavior. """
    def __init__(self, robot_name=None, is_turtlebot=False):
        """
        Initialize some ROS stuff (pub/sub, actionlib client) and also
        our state machine.
        """
        # Node name
        if robot_name:
            self.robot_name = robot_name
        else:
            # a random ID with dashes and underscores removed
            self.robot_name = str(uuid.uuid1()).replace('-','').replace('_','')
        #rospy.loginfo("Robot name: {0}".format(self.robot_name))
        print("Robot name: {0}".format(self.robot_name))

        self.is_turtlebot = is_turtlebot
        if is_turtlebot:
            self.is_turtlebot = True
            #rospy.loginfo("We're a real Turtlebot!")
        #else:
            #rospy.loginfo("We're a simulated Turtlebot!")

        # Our current estimated pose. This should be received the navigation
        # stack's amcl localization package. See on_my_pose_received().
        self.current_pose = None

        # Our current task (mrta.SensorSweepTask)
        self.current_task = None

        self.other_poses = defaultdict(geometry_msgs.msg.Pose)
        self.amcl_pose_subs = {}

        # Keep track of potential collisions with other robots
        self.collisions = defaultdict(Collision)

        self.in_collision = False

        # For some mechanisms, in order to compute a bid value (path cost)
        # we need to compute a path from the position of the most-recently-
        # awarded task point, rather than from the robot's current position.
        self.last_won_location = None

        # List of tasks that we have been awarded (SensorSweepTask)
        self.agenda = []

        # Unless true, we may only bid on tasks but NOT begin executing tasks
        self.ok_to_execute = False

        # Initialize our node
        node_name = 'mrta_robot_controller'
        rospy.loginfo("Starting node '{0}'...".format(node_name))
        rospy.init_node(node_name)

        # The rate at which we'll sleep while idle
        self.rate = rospy.Rate(RATE)

        rospy.loginfo("Robot name: {0}".format(self.robot_name))
        if self.is_turtlebot:
            rospy.loginfo("We're a real Turtlebot!")
        else:
            rospy.loginfo("We're a simulated Turtlebot!")

        # Topics we wish to subscribe to
        self.init_subscribers()

        # Topics we wish to publish
        self.init_publishers()

        # actionlib client; used to send goals to the navigation stack
        if self.is_turtlebot:
            ac_name = '/move_base'
        else:
            ac_name = "/{0}/move_base".format(self.robot_name)
            
        rospy.loginfo("Starting actionlib client '{0}'".format(ac_name))
        self.aclient = SimpleActionClient(ac_name,
                                          move_base_msgs.msg.MoveBaseAction)

        # Wait until the action server has started up
        self.aclient.wait_for_server()
        rospy.loginfo("{0} connected.".format(ac_name))

        # The name of the planner and 'clear_costmaps' services
        if self.is_turtlebot:
            self.plan_srv_name = '/move_base/NavfnROS/make_plan'
            self.cc_srv_name = '/move_base/clear_costmaps'
        else:
            #self.plan_srv_name = "/{0}/move_base_node/NavfnROS/make_plan".format(self.robot_name)
            self.plan_srv_name = "/{0}/move_base_node/GlobalPlanner/make_plan".format(self.robot_name)
            #self.plan_srv_name = "/{0}/move_base_node/HRTeamPlanner/make_plan".format(self.robot_name)
            self.cc_srv_name = "/{0}/move_base_node/clear_costmaps".format(self.robot_name)

        # Set up state machine.
        # See mrta/docs/robot-controller.fsm.png
        self.fsm = Fysom(
            events=[
                ('startup', 'none', 'idle'),

                # Choosing/sending goals
                ('have_incomplete_tasks', 'idle', 'choose_task'),
                ('no_incomplete_tasks', 'idle', 'idle'),
                #('no_tasks', 'idle', 'idle'),
                ('goal_chosen', 'choose_task', 'send_goal'),
                ('no_reachable_tasks', 'choose_task', 'idle'),
                ('goal_sent', 'send_goal', 'moving'),

                # Goal success/failure
                ('goal_reached', '*', 'task_success'),
                ('resume', 'task_success', 'idle'),
                ('goal_not_reached', '*', 'task_failure'),
                ('resume', 'task_failure', 'idle'),

                # Pause/resume
                ('pause', 'moving', 'paused'),
                ('resume', 'paused', 'moving'),

                # Collision avoidance
                #('collision_detected', 'moving', 'resolve_collision'),
                ('collision_detected', '*', 'resolve_collision'),
                #('collision_detected', 'paused', 'resolve_collision'),
                #('collision_resolved', 'resolve_collision', 'idle'),
                ('collision_resolved', '*', 'idle'),
            ],
            callbacks={
                'onidle': self.idle,
                #'onbid': self.bid,
                #'onwon': self.won,
                'onchoose_task': self.choose_task,
                'onsend_goal': self.send_goal,
                'onmoving': self.moving,
                'ontask_success': self.task_success,
                'ontask_failure': self.task_failure,
                'onshutdown': self.shutdown,
                'onresolve_collision': self.resolve_collision
            }
        )

        # Start the state machine
        self.fsm.startup()

        # Set up smach state machine
        # sm = smach.StateMachine(outcomes=['shutdown'])

        # with sm:
        #     # IDLE
        #     smach.StateMachine.add('IDLE', Idle(),
        #                            transitions={'have_tasks': 'CHOOSE_TASK',
        #                                         'no_tasks': 'IDLE'})

        #     # CHOOSE_TASK
        #     smach.StateMachine.add('CHOOSE_TASK', ChooseTask(),
        #                            transitions={'goal_chosen': 'SEND_GOAL',
        #                                         'no_tasks': 'IDLE'})

        # # smach introspection server
        # sis = smach_ros.IntrospectionServer("{0}_sis".format(self.robot_name), sm,
        #                                     "/{0}/SM_ROOT".format(self.robot_name))
        # sis.start()


        # # Run the smach state machine
        # outcome = sm.execute()

    def init_subscribers(self):
        rospy.loginfo('Initializing subscribers...')

        # '/experiment'
        self.experiment_sub = rospy.Subscriber(
            '/experiment',
            mrta.msg.ExperimentEvent,
            self.on_experiment_event_received)
        rospy.loginfo('subscribed to /experiment')

        # If we're a Turtlebot, subscribe to '/amcl_pose' and republish
        # on '/{self.robot_name}/amcl_pose'
        if self.is_turtlebot:
            self.self_amcl_pose_sub  = rospy.Subscriber('/amcl_pose',
                                                        geometry_msgs.msg.PoseWithCovarianceStamped,
                                                        self.on_tb_pose_received)

        # '/robot_<n>/amcl_pose'
        for robot_num in range(1, 4):
            r_name = "robot_{0}".format(robot_num)

            callback = None
            if r_name == self.robot_name:
                callback = self.on_my_pose_received
            else:
                callback = self.on_teammate_pose_received

            self.amcl_pose_subs[r_name] = rospy.Subscriber(
                "/{0}/amcl_pose".format(r_name),
                geometry_msgs.msg.PoseWithCovarianceStamped,
                callback, callback_args=r_name)
            rospy.loginfo("subscribed to /{0}/amcl_pose".format(r_name))

        # '/tasks/announce'
        # We respond only to sensor sweep task announcements (for now)
        self.announce_sub = rospy.Subscriber('/tasks/announce',
                                             mrta.msg.AnnounceSensorSweep,
                                             self.bid)
        rospy.loginfo('subscribed to /tasks/announce')

        # '/tasks/award'
        self.announce_sub = rospy.Subscriber('/tasks/award',
                                             mrta.msg.TaskAward,
                                             self.won)
        rospy.loginfo('subscribed to /tasks/award')

        # For good measure...
        time.sleep(3)

    def init_publishers(self):
        # If we're a Turtlebot, echo /amcl_pose to /{self.robot_name/amcl_pose
        if self.is_turtlebot:
            self.amcl_echo_pub = rospy.Publisher("/{0}/amcl_pose".format(self.robot_name),
                                                 geometry_msgs.msg.PoseWithCovarianceStamped,
                                                 latch=True)
            rospy.loginfo("echoing /amcl_pose on /{0}/amcl_pose".format(self.robot_name))

        # '/tasks/bid'
        self.bid_pub = rospy.Publisher('/tasks/bid',
                                       mrta.msg.TaskBid)
        rospy.loginfo('publishing on /tasks/bid')

        # Announce task events on '/tasks/status':
        # 'BEGIN', 'PAUSE', 'RESUME', 'SUCCESS', 'FAILURE', 'ALL_TASKS_COMPLETE'
        self.task_status_pub = rospy.Publisher('/tasks/status',
                                               mrta.msg.TaskStatus)
        rospy.loginfo('publishing on /tasks/status')

        # For good measure...
        time.sleep(3)

    def _point_to_point_msg(self, point):
        """Convert a mrta.Point to a geometry_msgs.msg.Point"""
        point_msg = geometry_msgs.msg.Point()
        point_msg.x = point.x
        point_msg.y = point.y
        point_msg.z = point.z

        return point_msg

    def _point_to_pose(self, point):
        pose_msg = geometry_msgs.msg.Pose()
        pose_msg.position = point
        pose_msg.orientation.w = 1.0

        return pose_msg

    def _pose_to_posestamped(self, pose, frame_id='map'):
        pose_stamped_msg = geometry_msgs.msg.PoseStamped()

        pose_stamped_msg.header.stamp = rospy.get_rostime()
        pose_stamped_msg.header.frame_id = frame_id
        pose_stamped_msg.pose = pose

        return pose_stamped_msg

    def _clear_costmaps(self):

        rospy.logdebug("Waiting for service {0}".format(self.plan_cc_name))
        rospy.wait_for_service(self.cc_srv_name)
        rospy.logdebug("Service ready.")

        try:
            clear_costmaps_proxy = rospy.ServiceProxy(self.cc_srv_name,
                                                      std_srvs.srv.Empty)

            clear_costmaps_proxy()

            rospy.logdebug("({0}) cleared costmaps".format(self.robot_name))

        except rospy.ServiceException, e:
            rospy.logerr("Service call failed: {0}".format(e))


    def _make_nav_plan_client(self, start, goal):

        rospy.logdebug("Waiting for service {0}".format(self.plan_srv_name))
        rospy.wait_for_service(self.plan_srv_name)
        rospy.logdebug("Service ready.")

        try:
            make_nav_plan = rospy.ServiceProxy(self.plan_srv_name,
                                               nav_msgs.srv.GetPlan)

            # We need to convert start and goal from type geometry_msgs.Pose
            # to type geometry_msgs.PoseStamped. tolerance (from the docs):
            # "If the goal is obstructed, how many meters the planner can
            # relax the constraint in x and y before failing."
            start_stamped = self._pose_to_posestamped(start)
            goal_stamped = self._pose_to_posestamped(goal)

            req = nav_msgs.srv.GetPlanRequest()
            req.start = start_stamped
            req.goal = goal_stamped
            req.tolerance = 0.1

            resp = make_nav_plan(req)

            rospy.logdebug("Got plan:\n{0}".format(pp.pformat(resp)))

            return resp.plan.poses

        except rospy.ServiceException, e:
            rospy.logerr("Service call failed: {0}".format(e))

    def _normalize_angle(self, angle):
        res = angle
        while res > math.pi:
            res -= 2.0 * math.pi
        while res < -pi:
            res += 2.0 * math.pi
        return res

    def handle_collision(self, other_name, other_pose):
        if self.fsm.current == 'moving' and in_danger_zone(self.current_pose, other_pose):
            rospy.loginfo("({0}) In danger of colliding with {0}".format(self.robot_name,other_name))

    def get_path_cost(self, start, goal):
        """
        Return the cost of a path from start to goal. The path is obtained
        from the navfn/MakeNavPlan service. The cost is the sum of distances
        between points in the path PLUS the angular changes (in randians)
        needed to re-orient from every point to its successor.

        This is taken from the alufr ROS package. See getPlanCost() in
        navstack_module.cpp at:
        https://code.google.com/p/alufr-ros-pkg/source/browse/.
        """

        #rospy.loginfo("Getting path from {0}...".format(self.plan_srv_name))

        # 'path' is a list of objects of type geometry_msgs.PoseStamped
        path = self._make_nav_plan_client(start, goal)

        #rospy.loginfo('...got path')

        path_cost = 0.0
        from_pose = None
        for pose_stamped in path:
            if from_pose is None:
                from_pose = pose_stamped.pose
                continue
            else:
                to_pose = pose_stamped.pose

                pos_delta = math.hypot(
                    to_pose.position.x - from_pose.position.x,
                    to_pose.position.y - from_pose.position.y)

                rospy.logdebug("pos_delta: {0}".format(pos_delta))

                path_cost += pos_delta

                ## Adding rotational distance to the path cost sounds cool, but
                ## the path returned by make_plan doesn't seem to specify
                ## orientations in its poses.
                #yaw_to = tf.transformations.euler_from_quaternion(to_pose.orientation)[2]
                #yaw_from = tf.transformations.euler_from_quaternion(from_pose.orientation)[2]
                #yaw_delta = math.fabs(self._normalize_angle(yaw_to-yaw_from))
                #path_cost += yaw_delta

                from_pose = pose_stamped.pose

        # If a path can't be calculated, make its cost the maximum int value
        # This comparison should be safe in Python!
        if path_cost == 0.0:
            path_cost = float(sys.maxint)

        rospy.loginfo("Path cost from ({0},{1}) to ({2},{3}) is {4}".format(
            start.position.x, start.position.y,
            goal.position.x, goal.position.y,
            path_cost))

        return path_cost

    def _cumulative_cost(self, start, tasks=None, greedy=True):
        """
        Get the cumulative cost of performing all tasks (visiting task points)
        from start. If greedy==True, tasks are ordered to minimize the cost of
        each hop (i.e., the next closest task is chosen). Otherwise, the
        original list order is used.
        """
        cumulative_cost = 0.0

        # Only consider tasks that haven't been completed yet
        tasks = [t for t in tasks if not t.completed]

        if greedy:
            #rospy.logdebug("_cumulative_cost(), tasks:\n{0}".format(pp.pformat(tasks)))

            tasks_copy = tasks[:]
            reordered_tasks = []

            from_pose = start
            while tasks_copy:
                min_cost = None
                min_cost_task = None
                for task in tasks_copy:
                    to_pose = self._point_to_pose(task.location)
                    cost = self.get_path_cost(from_pose, to_pose)

                    rospy.logdebug("cost from {0} to {1} is {2}".format(pp.pformat(from_pose),
                                                                        pp.pformat(to_pose),
                                                                        cost))

                    if min_cost is None or cost < min_cost:
                        min_cost = cost
                        min_cost_task = task

                reordered_tasks.append(min_cost_task)
                tasks_copy.remove(min_cost_task)
                from_pose = self._point_to_pose(min_cost_task.location)

            tasks = reordered_tasks
            rospy.logdebug("tasks=reordered_tasks={0}".format(pp.pformat(tasks)))

        from_pose = start
        for task in tasks:
            to_pose = self._point_to_pose(task.location)
            cost = self.get_path_cost(from_pose, to_pose)
            cumulative_cost += cost
            from_pose = to_pose

        final_pose = None
        if tasks:
            final_pose = self._point_to_pose(tasks[-1].location)
        else:
            final_pose = start

        return (cumulative_cost, final_pose)

    def on_task_announced(self, msg):
        # Trigger the 'task_announced' fsm event, with the message as a parameter
        rospy.logdebug("task announced:\n{0}".format(pp.pformat(msg)))
        self.fsm.task_announced(msg=msg)

    def on_task_award(self, msg):
        # Trigger the 'task_won' fsm event, with the message as a parameter
        rospy.logdebug("task won:\n{0}".format(pp.pformat(msg)))
        self.fsm.task_won(msg=msg)

    def _construct_bid_msg(self, task_id, robot_id, bid):
        bid_msg = mrta.msg.TaskBid()
        bid_msg.task_id = task_id
        bid_msg.robot_id = robot_id
        bid_msg.bid = bid

        return bid_msg

    def bid(self, announce_msg):
        rospy.loginfo("({0}): bid()".format(self.robot_name))

        rospy.logdebug("({0}) announce_msg:\n{1}".format(self.robot_name,
                                                        pp.pformat(announce_msg)))

        # Our bid-from point is the location of our most recently won task,
        # if any. If we haven't won any tasks, bid from our current position.
        # bid_from = None
        # if self.last_won_location:
        #     # Convert last_won_location from a Point to a Pose
        #     bid_from = self._point_to_pose(self.last_won_location)
        # else:
        #     bid_from = self.current_pose

        # The mechanism determines the number and kind of bids we make
        if announce_msg.mechanism == 'OSI':
            rospy.logdebug("({0}) mechanism == OSI".format(self.robot_name))

            task_msg = announce_msg.tasks[0]

            # path_cost = self.get_path_cost(bid_from,
            #                                self._point_to_pose(task_msg.location))


            # Get the cumulative cost of all tasks in out agenda so far
            (c_cost, bid_from) = self._cumulative_cost(self.current_pose,
                                                       self.agenda,
                                                       greedy=True)

            rospy.loginfo("({0}) cumulative cost: {1}".format(self.robot_name,
                                                              c_cost))

            new_task_cost = self.get_path_cost(bid_from,
                                               self._point_to_pose(task_msg.location))

            path_cost = c_cost + new_task_cost

            rospy.loginfo("({0}) path_cost to task {1}: {2}".format(
                self.robot_name,
                task_msg.task.task_id,
                path_cost))

            bid_msg = self._construct_bid_msg(task_msg.task.task_id,
                                              self.robot_name,
                                              path_cost)
            stamp(bid_msg)
            rospy.loginfo("bid_msg:\n{0}".format(pp.pformat(bid_msg)))
            self.bid_pub.publish(bid_msg)

        elif announce_msg.mechanism == 'PSI':
            rospy.logdebug("({0}) mechanism == PSI".format(self.robot_name))
            rospy.loginfo("mechanism == PSI")

            # In PSI we always calculate bids (path costs) from our current
            # position
            bid_from = self.current_pose

            for task_msg in announce_msg.tasks:
                path_cost = self.get_path_cost(bid_from,
                                               self._point_to_pose(task_msg.location))

                rospy.loginfo("({0}) path_cost to task {1}: {2}".format(
                    self.robot_name,
                    task_msg.task.task_id,
                    path_cost))

                bid_msg = self._construct_bid_msg(task_msg.task.task_id,
                                                  self.robot_name,
                                                  path_cost)

                stamp(bid_msg)
                rospy.logdebug("bid_msg:\n{0}".format(pp.pformat(bid_msg)))
                self.bid_pub.publish(bid_msg)

        elif announce_msg.mechanism == 'SSI':
            rospy.logdebug("({0}) mechanism == SSI".format(self.robot_name))

            # Get the cumulative cost of all tasks in out agenda so far
            (c_cost, bid_from) = self._cumulative_cost(self.current_pose,
                                                       self.agenda,
                                                       greedy=True)

            rospy.loginfo("({0}) cumulative cost: {1}".format(self.robot_name,
                                                              c_cost))
            minimum_cost = None
            minimum_cost_task_id = None

            for task_msg in announce_msg.tasks:
                #path_cost = self.get_path_cost(bid_from,
                #                               self._point_to_pose(task_msg.location))

                new_task_cost = self.get_path_cost(
                    bid_from,
                    self._point_to_pose(task_msg.location))

                path_cost = c_cost + new_task_cost

                rospy.loginfo("({0}) path_cost to task {1}: {2}".format(
                    self.robot_name,
                    task_msg.task.task_id,
                    path_cost))

                if minimum_cost is None or path_cost < minimum_cost:
                    minimum_cost = path_cost
                    minimum_cost_task_id = task_msg.task.task_id

            rospy.loginfo("({0}) minimum_cost={1} to task {2}".format(
                self.robot_name,
                minimum_cost,
                minimum_cost_task_id))

            bid_msg = self._construct_bid_msg(minimum_cost_task_id,
                                              self.robot_name,
                                              minimum_cost)

            stamp(bid_msg)
            rospy.logdebug("bid_msg:\n{0}".format(pp.pformat(bid_msg)))
            self.bid_pub.publish(bid_msg)

        else:
            rospy.logerr("bid(): mechanism '{0}' not supported".format(self.mechanism))

        rospy.loginfo("({0}) bid(): current_state=={1}".format(self.robot_name,
                                                               self.fsm.current))

    def won(self, award_msg):
        rospy.loginfo("({0}): won()".format(self.robot_name))

        # Make sure that this robot won the task
        if award_msg.robot_id != self.robot_name:
            return

        for task_msg in award_msg.tasks:
            rospy.loginfo("({0}) I won task {1}!".format(self.robot_name,
                                                         task_msg.task.task_id))
            new_task = mrta.SensorSweepTask(str(task_msg.task.task_id),
                                                         float(task_msg.location.x),
                                                         float(task_msg.location.y))
            self.agenda.append(new_task)
            self.last_won_location = task_msg.location

        rospy.loginfo("({0}) won(): current_state=={1}".format(self.robot_name,
                                                               self.fsm.current))

    def choose_task(self, e):
        rospy.loginfo("({0}) state: choose_task".format(self.robot_name))

        # We have two ways to choose the next task from our agenda:
        # 1. ("non-greedy") Choose the first task that hasn't been completed yet
        # 2. ("greedy")     Choose the next closest task

        greedy_selection = True

        goal_task = None
        min_uncompleted_dist = None
        for task in self.agenda:
            if not task.completed:
                if greedy_selection:
                    from_pose = self.current_pose
                    to_pose = self._point_to_pose(self._point_to_point_msg(task.location))
                    path_cost = self.get_path_cost(from_pose, to_pose)

                    if not min_uncompleted_dist or path_cost < min_uncompleted_dist:
                        goal_task = task
                        min_uncompleted_dist = path_cost

                else:
                    goal_task = task
                    break

        self.current_task = goal_task

        # Sanity check
        if not self.current_task:
            rospy.loginfo("({0}) event: no_tasks".format(robot_name))
            self.fsm.no_tasks()

        # If the minimum cost (closest task) is sys.maxint, then
        # we don't have any valid paths
        if min_uncompleted_dist > 100000:
            rospy.loginfo("({0}) There are no reachable tasks. Clearing costmaps manually...".format(self.robot_name))
            self. _clear_costmaps()
            time.sleep(1)
            self.fsm.no_reachable_tasks()
            return

        rospy.loginfo("({0}) event: goal_chosen".format(self.robot_name))
        self.fsm.goal_chosen()

    def on_tb_pose_received(self, amcl_pose_msg):
        """ Echo poses published on /amcl_pose to /{self.robot_name}/amcl_pose"""
        rospy.loginfo("on_tb_pose_received(): /amcl_pose received")
        try:
            if self.amcl_echo_pub:
                self.amcl_echo_pub.publish(amcl_pose_msg)
        except AttributeError:
            return
                
    def on_my_pose_received(self, amcl_pose_msg, r_name):
        # amcl_pose_msg is typed as geometry_msgs/PoseWithCovarianceStamped.
        # We'll just keep track of amcl_pose_msg.pose.pose, which is typed as
        # geometry_msgs/Pose
        self.current_pose = amcl_pose_msg.pose.pose

    def on_teammate_pose_received(self, amcl_pose_msg, r_name):

        # self.fsm might not be initialized yet
        try:
            if self.fsm:
                pass
        except AttributeError:
            return

        # amcl_pose_msg is typed as geometry_msgs/PoseWithCovarianceStamped.
        # We'll just keep track of amcl_pose_msg.pose.pose, which is typed as
        # geometry_msgs/Pose
        other_pose = amcl_pose_msg.pose.pose
        self.other_poses[r_name] = other_pose

        if in_danger_zone(self.current_pose, other_pose):
            #rospy.loginfo("({0}) In danger of colliding with {1}".format(self.robot_name,r_name))
            #rospy.loginfo("({0}) Current state: {1}".format(self.robot_name,self.fsm.current))

            if self.fsm.current == 'moving':

                self.fsm.collision_detected(other_robot_name=r_name)
        #else:
            #if self.fsm.current == 'resolve_collision':
                #self.fsm.collision_resolved()

        else:
            self.in_collision = False

        #rospy.loginfo("Got {0}'s pose:\n{1}".format(r_name, pp.pformat(self.other_poses[r_name])))

    def on_experiment_event_received(self, event_msg):
        if event_msg.event == 'BEGIN_ALLOCATION':
            rospy.loginfo("({0}) BEGIN_ALLOCATION: ok_to_execute==False".format(self.robot_name))
            self.ok_to_execute = False
            self.aclient.cancel_goal()

        elif event_msg.event == 'BEGIN_EXECUTION':
            rospy.loginfo("({0}) BEGIN_EXECUTION: ok_to_execute==True".format(self.robot_name))
            self.ok_to_execute = True
            rospy.loginfo("({0}) BEGIN_EXECUTION: current state=={1}".format(self.robot_name,
                                                                             self.fsm.current))

        #elif event_msg.event == 'END_EXPERIMENT':
        #    self.shutdown(None)

    # def goal_done_cb(self, term_state, result):
    #     rospy.loginfo("goal_done_cb(): term_state=={0}, result=={1}".format(term_state,
    #                                                                         result))
    #     if term_state == actionlib_msgs.msg.GoalStatus.SUCCEEDED:
    #         self.fsm.goal_reached()
    #     else:
    #         self.fsm.goal_not_reached()

    def send_goal(self, e):
        rospy.loginfo("({0}) state: send_goal".format(self.robot_name))

        # Clear costmaps first, just to be safe
        self._clear_costmaps()

        goal_task = self.current_task

        # Send a message to mark the beginning of this task's execution
        begin_task_msg = mrta.msg.TaskStatus()
        begin_task_msg.robot_id = self.robot_name
        begin_task_msg.task_id = goal_task.task_id
        begin_task_msg.status = 'BEGIN'
        stamp(begin_task_msg)
        self.task_status_pub.publish(begin_task_msg)

        # Construct the goal message to send to the move_base service
        goal_msg = move_base_msgs.msg.MoveBaseGoal()
        goal_msg.target_pose.header.frame_id = 'map'
        goal_msg.target_pose.header.stamp = rospy.Time.now()

        goal_msg.target_pose.pose.position.x = float(goal_task.location.x)
        goal_msg.target_pose.pose.position.y = float(goal_task.location.y)
        goal_msg.target_pose.pose.orientation.z = 1.0
        goal_msg.target_pose.pose.orientation.w = 0.0

        rospy.loginfo("Sending goal: {0}".format(pp.pformat(goal_msg)))
        #self.aclient.send_goal(goal_msg, done_cb=self.goal_done_cb)
        self.aclient.send_goal(goal_msg)

        self.fsm.goal_sent()

    def resolve_collision(self, e):
        rospy.loginfo("({0}) state: resolve_collision".format(self.robot_name))

        # This might work...
        #if self.robot_name > e.other_robot_name:
        #    self.in_collision = True

        goal_task = self.current_task

        rospy.loginfo("({0}) Pausing to avoid collision...".format(self.robot_name))
        self.aclient.cancel_goal()

        # Mark a pause in this task's execution
        pause_task_msg = mrta.msg.TaskStatus()
        pause_task_msg.robot_id = self.robot_name
        pause_task_msg.task_id = goal_task.task_id
        pause_task_msg.status = 'PAUSE'
        stamp(pause_task_msg)
        self.task_status_pub.publish(pause_task_msg)

        #while self.in_collision:
        #    self.rate.sleep()

        #time.sleep(1)

        if self.robot_name > e.other_robot_name:
            # Duration to pause
            pause_duration = 1 + random.random()
            time.sleep(pause_duration)

        rospy.loginfo("({0}) Resuming...".format(self.robot_name))

        # Mark a resumption of this task's execution
        resume_task_msg = mrta.msg.TaskStatus()
        resume_task_msg.robot_id = self.robot_name
        resume_task_msg.task_id = goal_task.task_id
        resume_task_msg.status = 'RESUME'
        stamp(resume_task_msg)
        self.task_status_pub.publish(resume_task_msg)

        self.fsm.collision_resolved()

    def moving(self, e):
        rospy.loginfo("({0}) state: moving".format(self.robot_name))

        # Wait until the goal is reached
        self.aclient.wait_for_result()

        # The actionlib client will send a "goal reached" message, triggering
        # goal_done_cb() to change the current state. Wait here until then.
        #while self.fsm.current == 'moving':
        #    self.rate.sleep()

        rospy.loginfo("({0}) IN 'moving', state: {1}".format(self.robot_name, self.fsm.current))

        # Sometimes wait_for_result() returns, but the goal is still active. Why?
        while self.aclient.get_state() == actionlib_msgs.msg.GoalStatus.ACTIVE:
            time.sleep(0.5)

        # If resolving collisions, just return here
        if self.fsm.current == 'resolve_collision':
            return

        if self.aclient.get_state() == actionlib_msgs.msg.GoalStatus.SUCCEEDED:
            self.fsm.goal_reached()
        else:
            rospy.loginfo("GoalStatus=={0}".format(self.aclient.get_state()))
            # hax...
            if self.fsm.current == 'moving':
                self.fsm.goal_not_reached()

    def task_success(self, e):
        rospy.loginfo("({0}) state: task_success".format(self.robot_name))

        goal_task = self.current_task

        rospy.loginfo("({0}) publishing 'SUCCESS' to /tasks/status".format(self.robot_name))

        # Send a message to mark the end of this task's execution
        end_task_msg = mrta.msg.TaskStatus()
        end_task_msg.robot_id = self.robot_name
        end_task_msg.task_id = goal_task.task_id
        end_task_msg.status = 'SUCCESS'
        stamp(end_task_msg)
        self.task_status_pub.publish(end_task_msg)

        goal_task.completed = True
        self.current_task = None

        time.sleep(1)

        self.fsm.resume()

    def task_failure(self, e):
        rospy.loginfo("({0}) state: task_failure".format(self.robot_name))

        goal_task = self.current_task

        rospy.loginfo("({0}) publishing 'FAILURE' to /tasks/status".format(self.robot_name))

        # Send a message to mark the end of this task's execution
        end_task_msg = mrta.msg.TaskStatus()
        end_task_msg.robot_id = self.robot_name
        end_task_msg.task_id = goal_task.task_id
        end_task_msg.status = 'FAILURE'
        stamp(end_task_msg)
        self.task_status_pub.publish(end_task_msg)

        goal_task.completed = False
        self.current_task = None

        time.sleep(1)

        self.fsm.resume()

    def idle(self, e):
        rospy.loginfo("({0}) state: idle".format(self.robot_name))

        # We idle here unless two conditions are true:
        # 1. We have incomplete tasks in our agenda
        # 2. self.ok_to_execute == True
        have_incomplete_tasks = False
        while not have_incomplete_tasks or not self.ok_to_execute:
            rospy.logdebug("no incomplete tasks or ok_to_execute==False")

            self.rate.sleep()

            for task in self.agenda:
                if not task.completed:
                    have_incomplete_tasks = True
                    break


        rospy.logdebug("({0}) have_incomplete_tasks=={1}".format(self.robot_name,
                                                                have_incomplete_tasks))

        if have_incomplete_tasks:
            self.fsm.have_incomplete_tasks()
        #else:
            # The allocation and execution phases are finished.

            # Send a message to mark the completion of all tasks
            #all_complete_msg = mrta.msg.TaskStatus()
            #all_complete_msg.robot_id = self.robot_name
            #all_complete_msg.task_id = '*'
            #all_complete_msg.status = 'ALL_TASKS_COMPLETE'
            #stamp(all_complete_msg)
            #self.task_status_pub.publish(all_complete_msg)

            #self.fsm.no_incomplete_tasks()

    def shutdown(self, e):
        # Do any cleanup here before shutting down

        rospy.loginfo("{0} shutting down...".format(self.robot_name))

        # Instead of exiting, wait to be shut down from outside
        #sys.exit(0)
        while not rospy.is_shutdown():
            self.rate.sleep()

if __name__ == '__main__':

    try:
        argv = rospy.myargv(argv=sys.argv[1:])
        #print "arguments: {0}".format(argv)
        rc = RobotController(*argv)
        #print("rc final state: {0}".format(rc.fsm.current))

        while not rospy.is_shutdown():
            rc.rate.sleep()

    except rospy.ROSInterruptException:
        pass

    print('######## robot_controller exiting ########')
